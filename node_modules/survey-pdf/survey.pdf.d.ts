/*Type definitions for SurveyJS PDF library v1.12.16-patch.1
Copyright (c) 2015-2024 Devsoft Baltic OÜ  - http://surveyjs.io/
Definitions by: Devsoft Baltic OÜ <https://github.com/surveyjs/>
*/
// Dependencies for this module:
//   ../../../../survey-core

import { SurveyModel, EventBase } from 'survey-core';
import { IQuestion, Question, QuestionRatingModel, QuestionFileModel, LocalizableString } from 'survey-core';
import { ItemValue, QuestionBooleanModel } from 'survey-core';
import { QuestionCheckboxModel, QuestionTagboxModel } from 'survey-core';
import { QuestionCommentModel } from 'survey-core';
import { QuestionDropdownModel } from 'survey-core';
import { QuestionExpressionModel } from 'survey-core';
import { QuestionHtmlModel } from 'survey-core';
import { QuestionImageModel } from 'survey-core';
import { QuestionImagePickerModel } from 'survey-core';
import { QuestionPanelDynamicModel } from 'survey-core';
import { QuestionRadiogroupModel } from 'survey-core';
import { QuestionRankingModel } from 'survey-core';
import { QuestionCheckboxBase } from 'survey-core';
import { QuestionSignaturePadModel } from 'survey-core';
import { QuestionTextModel } from 'survey-core';
import { PanelModel } from 'survey-core';
import { QuestionMatrixModel, MatrixRowModel } from 'survey-core';
import { QuestionMatrixDropdownModelBase } from 'survey-core';
import { QuestionMultipleTextModel } from 'survey-core';
import { PageModel } from 'survey-core';

/**
    * The `SurveyPDF` object enables you to export your surveys and forms to PDF documents.
    *
    * [View Demo](https://surveyjs.io/pdf-generator/examples/ (linkStyle))
    */
export declare class SurveyPDF extends SurveyModel {
        options: IDocOptions;
        constructor(jsonObject: any, options?: IDocOptions);
        get haveCommercialLicense(): boolean;
        set haveCommercialLicense(val: boolean);
        /**
            * An event that is raised when SurveyJS PDF Generator renders a page header. Handle this event to customize the header.
            *
            * Parameters:
            *
            * - `sender`: `SurveyPDF`\
            * A SurveyPDF instance that raised the event.
            *
            * - `canvas`: [`DrawCanvas`](https://surveyjs.io/pdf-generator/documentation/api-reference/drawcanvas)\
            * An object that you can use to draw text and images in the page header.
            *
            * [View Demo](https://surveyjs.io/pdf-generator/examples/customize-header-and-footer-of-pdf-form/ (linkStyle))
            */
        onRenderHeader: EventAsync<SurveyPDF, DrawCanvas>;
        /**
            * An event that is raised when SurveyJS PDF Generator renders a page footer. Handle this event to customize the footer.
            *
            * Parameters:
            *
            * - `sender`: `SurveyPDF`\
            * A SurveyPDF instance that raised the event.
            *
            * - `canvas`: [`DrawCanvas`](https://surveyjs.io/pdf-generator/documentation/api-reference/drawcanvas)\
            * An object that you can use to draw text and images in the page footer.
            *
            * [View Demo](https://surveyjs.io/pdf-generator/examples/customize-header-and-footer-of-pdf-form/ (linkStyle))
            */
        onRenderFooter: EventAsync<SurveyPDF, DrawCanvas>;
        /**
            * An event that is raised when SurveyJS PDF Generator renders a survey question. Handle this event to customize question rendering.
            *
            * Parameters:
            *
            * - `sender`: `SurveyPDF`\
            * A SurveyPDF instance that raised the event.
            *
            * - `options.question`: [`Question`](https://surveyjs.io/form-library/documentation/api-reference/question)\
            * A survey question that is being rendered.
            *
            * - `options.point`: `IPoint`\
            * An object with coordinates of the top-left corner of the element being rendered. This object contains the following properties: `{ xLeft: number, yTop: number }`.
            *
            * - `options.bricks`: [`PdfBrick[]`](https://surveyjs.io/pdf-generator/documentation/api-reference/pdfbrick)\
            * An array of [bricks](https://surveyjs.io/pdf-generator/documentation/customize-survey-question-rendering-in-pdf-form#custom-rendering) used to render the element.
            *
            * - `options.controller`: [`DocController`](https://surveyjs.io/pdf-generator/documentation/api-reference/doccontroller)\
            * An object that provides access to main PDF document properties (font, margins, page width and height) and allows you to modify them.
            *
            * - `options.repository`: `FlatRepository`\
            * A repository with classes that render elements to PDF. Use its `create` method if you need to create a new instance of a rendering class.
            *
            * [View Demo](https://surveyjs.io/pdf-generator/examples/how-to-use-adorners-in-pdf-forms/ (linkStyle))
            */
        onRenderQuestion: EventAsync<SurveyPDF, AdornersOptions>;
        /**
            * An event that is raised when SurveyJS PDF Generator renders a panel. Handle this event to customize panel rendering.
            *
            * Parameters:
            *
            * - `sender`: `SurveyPDF`\
            * A SurveyPDF instance that raised the event.
            *
            * - `options.panel`: [`PanelModel`](https://surveyjs.io/form-library/documentation/api-reference/panel-model)\
            * A panel that is being rendered.
            *
            * - `options.point`: `IPoint`\
            * An object with coordinates of the top-left corner of the element being rendered. This object contains the following properties: `{ xLeft: number, yTop: number }`.
            *
            * - `options.bricks`: [`PdfBrick[]`](https://surveyjs.io/pdf-generator/documentation/api-reference/pdfbrick)\
            * An array of [bricks](https://surveyjs.io/pdf-generator/documentation/customize-survey-question-rendering-in-pdf-form#custom-rendering) used to render the element.
            *
            * - `options.controller`: [`DocController`](https://surveyjs.io/pdf-generator/documentation/api-reference/doccontroller)\
            * An object that provides access to main PDF document properties (font, margins, page width and height) and allows you to modify them.
            *
            * - `options.repository`: `FlatRepository`\
            * A repository with classes that render elements to PDF. Use its `create` method if you need to create a new instance of a rendering class.
            *
            * [View Demo](https://surveyjs.io/pdf-generator/examples/how-to-use-adorners-in-pdf-forms/ (linkStyle))
            */
        onRenderPanel: EventAsync<SurveyPDF, AdornersPanelOptions>;
        /**
            * An event that is raised when SurveyJS PDF Generator renders a page. Handle this event to customize page rendering.
            *
            * Parameters:
            *
            * - `sender`: `SurveyPDF`\
            * A SurveyPDF instance that raised the event.
            *
            * - `options.page`: [`PageModel`](https://surveyjs.io/form-library/documentation/api-reference/page-model)\
            * A page that is being rendered.
            *
            * - `options.point`: `IPoint`\
            * An object with coordinates of the top-left corner of the element being rendered. This object contains the following properties: `{ xLeft: number, yTop: number }`.
            *
            * - `options.bricks`: [`PdfBrick[]`](https://surveyjs.io/pdf-generator/documentation/api-reference/pdfbrick)\
            * An array of [bricks](https://surveyjs.io/pdf-generator/documentation/customize-survey-question-rendering-in-pdf-form#custom-rendering) used to render the element.
            *
            * - `options.controller`: [`DocController`](https://surveyjs.io/pdf-generator/documentation/api-reference/doccontroller)\
            * An object that provides access to main PDF document properties (font, margins, page width and height) and allows you to modify them.
            *
            * - `options.repository`: `FlatRepository`\
            * A repository with classes that render elements to PDF. Use its `create` method if you need to create a new instance of a rendering class.
            *
            * [View Demo](https://surveyjs.io/pdf-generator/examples/how-to-use-adorners-in-pdf-forms/ (linkStyle))
            */
        onRenderPage: EventAsync<SurveyPDF, AdornersPageOptions>;
        onDocControllerCreated: EventBase<SurveyPDF, {
                controller: DocController;
        }>;
        onRenderCheckItemAcroform: EventAsync<SurveyPDF, any>;
        onRenderRadioGroupWrapAcroform: EventAsync<SurveyPDF, any>;
        onRenderRadioItemAcroform: EventAsync<SurveyPDF, any>;
        getUpdatedCheckItemAcroformOptions(options: any): void;
        getUpdatedRadioGroupWrapOptions(options: any): void;
        getUpdatedRadioItemAcroformOptions(options: any): void;
        protected renderSurvey(controller: DocController): Promise<void>;
        /**
            * An asynchronous method that starts download of the generated PDF file in the web browser.
            *
            * @param fileName *(Optional)* A file name with the ".pdf" extension. Default value: `"survey_result.pdf"`.
            */
        save(fileName?: string): Promise<any>;
        /**
            * An asynchronous method that allows you to get PDF content in different formats.
            *
            * [View Demo](https://surveyjs.io/pdf-generator/examples/convert-pdf-form-blob-base64-raw-pdf-javascript/ (linkStyle))
            *
            * @param type *(Optional)* One of `"blob"`, `"bloburl"`, `"dataurlstring"`. Do not specify this parameter if you want to get raw PDF content as a string value.
            *
            */
        raw(type?: string): Promise<string>;
}

export type IBorderDescription = IRect & ISize & Pick<PdfBrick, 'formBorderColor'> & {
    rounded?: boolean;
    dashStyle?: {
        dashArray: [number, number] | [number];
        dashPhase: number;
    };
    outside?: boolean;
};
export declare class SurveyHelper {
    static EPSILON: number;
    static TITLE_SURVEY_FONT_SIZE_SCALE: number;
    static TITLE_PAGE_FONT_SIZE_SCALE: number;
    static TITLE_PANEL_FONT_SIZE_SCALE: number;
    static DESCRIPTION_FONT_SIZE_SCALE: number;
    static OTHER_ROWS_COUNT: number;
    static RATING_MIN_WIDTH: number;
    static RATING_MIN_HEIGHT: number;
    static RATING_COLUMN_WIDTH: number;
    static MATRIX_COLUMN_WIDTH: number;
    static IMAGEPICKER_COUNT: number;
    static IMAGEPICKER_RATIO: number;
    static MULTIPLETEXT_TEXT_PERS: number;
    static HTML_TAIL_TEXT_SCALE: number;
    static SELECT_ITEM_FLAT_SCALE: number;
    static GAP_BETWEEN_ROWS: number;
    static GAP_BETWEEN_COLUMNS: number;
    static GAP_BETWEEN_ITEM_TEXT: number;
    static FORM_BORDER_VISIBLE: boolean;
    static BORDER_SCALE: number;
    static VISIBLE_BORDER_SCALE: number;
    static UNVISIBLE_BORDER_SCALE: number;
    static RADIUS_SCALE: number;
    static TITLE_FONT_SCALE: number;
    static VALUE_READONLY_PADDING_SCALE: number;
    static HTML_TO_IMAGE_QUALITY: number;
    static FORM_BORDER_COLOR: string;
    static TEXT_COLOR: string;
    static BACKGROUND_COLOR: string;
    static TITLE_LOCATION_MATRIX: string;
    static STANDARD_FONT: string;
    static CUSTOM_FONT_ENCODING: string;
    static parseWidth(width: string, maxWidth: number, columnsCount?: number, defaultUnit?: string): number;
    static pxToPt(value: number | string): number;
    static mergeRects(...rects: IRect[]): IRect;
    static createPoint(rect: IRect, isLeft?: boolean, isTop?: boolean): IPoint;
    static createRect(point: IPoint, width: number, height: number): IRect;
    static createHeaderRect(controller: DocController): IRect;
    static createFooterRect(controller: DocController): IRect;
    static chooseHtmlFont(controller: DocController): string;
    static generateCssTextRule(fontSize: number, fontStyle: string, fontName: string): string;
    static createHtmlContainerBlock(html: string, controller: DocController, renderAs: IHTMLRenderType): string;
    static splitHtmlRect(controller: DocController, htmlBrick: IPdfBrick): IPdfBrick;
    static createPlainTextFlat<T extends IPdfBrick>(point: IPoint, question: IQuestion, controller: DocController, text: string, fabric: new (question: IQuestion, controller: DocController, rect: IRect, text: string) => T): CompositeBrick;
    static createTextFlat<T extends IPdfBrick>(point: IPoint, question: IQuestion, controller: DocController, text: string | LocalizableString, fabric: new (question: IQuestion, controller: DocController, rect: IRect, text: string) => T): Promise<IPdfBrick>;
    static createHTMLRect(point: IPoint, controller: DocController, margins: {
        top: number;
        bottom: number;
        width: number;
    }, resultY: number): IRect;
    static createHTMLFlat(point: IPoint, question: Question, controller: DocController, html: string): Promise<IPdfBrick>;
    static generateFontFace(fontName: string, fontBase64: string, fontWeight: string): string;
    static generateFontFaceWithItalicStyle(fontName: string, fontBase64: string, fontWeight: string): string;
    static htmlToXml(html: string): string;
    static createSvgContent(html: string, width: number, controller: DocController): {
        svg: string;
        divWidth: number;
        divHeight: number;
    };
    static htmlToImage(html: string, width: number, controller: DocController): Promise<{
        url: string;
        aspect: number;
    }>;
    static createBoldTextFlat(point: IPoint, question: Question, controller: DocController, text: string | LocalizableString): Promise<IPdfBrick>;
    static createTitleFlat(point: IPoint, question: Question, controller: DocController): Promise<IPdfBrick>;
    static createTitleSurveyFlat(point: IPoint, controller: DocController, text: string | LocalizableString): Promise<IPdfBrick>;
    static createTitlePanelFlat(point: IPoint, controller: DocController, text: string | LocalizableString, isPage?: boolean): Promise<IPdfBrick>;
    static createDescFlat(point: IPoint, question: IQuestion, controller: DocController, text: string | LocalizableString): Promise<IPdfBrick>;
    static getReadonlyRenderAs(question: Question, controller: DocController): 'auto' | 'text' | 'acroform';
    static createCommentFlat(point: IPoint, question: Question, controller: DocController, isQuestion: boolean, options?: {
        rows?: number;
        index?: number;
        value?: string;
        readOnly?: boolean;
    }): Promise<IPdfBrick>;
    static getQuestionOrCommentValue(question: Question, isQuestion?: boolean): string;
    static getQuestionOrCommentDisplayValue(question: Question, isQuestion?: boolean): string;
    static inBrowser: boolean;
    static get hasDocument(): boolean;
    static getImageBase64(imageLink: string): Promise<string>;
    static shouldConvertImageToPng: boolean;
    static getImageLink(controller: DocController, imageOptions: {
        link: string;
        width: number;
        height: number;
        objectFit?: string;
    }, applyImageFit: boolean): Promise<string>;
    static createImageFlat(point: IPoint, question: any, controller: DocController, imageOptions: {
        link: string;
        width: number;
        height: number;
        objectFit?: string;
    }, applyImageFit?: boolean): Promise<IPdfBrick>;
    static canPreviewImage(question: QuestionFileModel, item: {
        name: string;
        type: string;
        content: string;
    }, url: string): boolean;
    static getImageSize(url: string): Promise<ISize>;
    static createRowlineFlat(point: IPoint, controller: DocController, width?: number, color?: string): IPdfBrick;
    static createLinkFlat(point: IPoint, question: Question, controller: DocController, text: string, link: string): Promise<IPdfBrick>;
    static createAcroformRect(rect: IRect): number[];
    static createTextFieldRect(point: IPoint, controller: DocController, lines?: number): IRect;
    static createReadOnlyTextFieldTextFlat(point: IPoint, controller: DocController, question: Question, value: string): Promise<IPdfBrick>;
    static renderFlatBorders(controller: DocController, borderOptions: IBorderDescription): void;
    static getLocString(text: LocalizableString): string;
    static getDropdownQuestionValue(question: Question): string;
    static getContentQuestion(question: Question): Question;
    static getContentQuestionTypeRenderAs(question: Question, survey: SurveyPDF): string;
    static getContentQuestionType(question: Question, survey: SurveyPDF): string;
    static getRatingMinWidth(controller: DocController): number;
    static getRatingItemText(question: QuestionRatingModel, index: number, locText: LocalizableString): LocalizableString;
    static getPageAvailableWidth(controller: DocController): number;
    static getImagePickerAvailableWidth(controller: DocController): number;
    static getColumnWidth(controller: DocController, colCount: number): number;
    static setColumnMargins(controller: DocController, colCount: number, column: number): void;
    static moveRect(rect: IRect, left?: number, top?: number): IRect;
    static scaleRect(rect: IRect, scale: number): IRect;
    static getBorderWidth(controller: DocController): number;
    static formScale(controller: DocController, flat: ISize): number;
    static generateQuestionFlats(survey: SurveyPDF, controller: DocController, question: Question, point: IPoint): Promise<IPdfBrick[]>;
    static isFontExist(controller: DocController, fontName: string): boolean;
    static isCustomFont(controller: DocController, fontName: string): boolean;
    static fixFont(controller: DocController): void;
    static clone(src: any): any;
    static shouldRenderReadOnly(question: IQuestion, controller: DocController, readOnly?: boolean): boolean;
    static isSizeEmpty(val: any): boolean;
    static isHeightEmpty(val: any): boolean;
    static getCorrectedImageSize(controller: DocController, imageOptions: {
        imageWidth?: any;
        imageHeight?: any;
        imageLink: string;
        defaultImageWidth?: any;
        defaultImageHeight?: any;
    }): Promise<ISize>;
}

import './jspdf_plugins/acroform.js';
import './jspdf_plugins/from_html.js';
export interface IPoint {
        /**
            * An X-coordinate for the left element edge.
            */
        xLeft: number;
        /**
            * A Y-coordinate for the top element edge.
            */
        yTop: number;
}
/**
    * An interface that describes a rectangle.
    */
export interface IRect extends IPoint {
        /**
            * An X-coordinate for the right element edge.
            */
        xRight: number;
        /**
            * A Y-coordinate for the bottom element edge.
            */
        yBot: number;
}
export interface ISize {
        width: number;
        height: number;
}
export interface IMarginLR {
        /**
            * A left margin.
            */
        left?: number;
        /**
            * A right margin.
            */
        right?: number;
}
/**
    * An interface that describes margins.
    */
export interface IMargin extends IMarginLR {
        /**
            * A top margin.
            */
        top?: number;
        /**
            * A bottom margin.
            */
        bot?: number;
}
/**
    * PDF document configuration. Pass it as the second argument to the `SurveyPDF` constructor:
    *
    * ```js
    * const surveyPdf = new SurveyPDF.SurveyPDF(surveyJson, pdfDocOptions);
    *
    * // In modular applications:
import { SurveyPDF } from "survey-pdf";
    * const surveyPdf = new SurveyPDF(surveyJson, pdfDocOptions);
    * ```
    */
export interface IDocOptions {
        /**
            * Page orientation.
            *
            * Possible values:
            *
            * - `"p"` (default) - Portrait orientation.
            * - `"l"` - Landscape orientation.
            *
            * @see format
            */
        orientation?: 'p' | 'l';
        /**
            * Page format.
            *
            * Possible values:
            *
            * - `"a0"` - `"a10"` (`"a4"` is default)
            * - `"b0"` - `"b10"`
            * - `"c0"` - `"c10"`
            * - `"dl"`
            * - `"letter"`
            * - `"government-letter"`
            * - `"legal"`
            * - `"junior-legal"`
            * - `"ledger"`
            * - `"tabloid"`
            * - `"credit-card"`
            * - Array<number> - custom page size in millimeters, for example, `[210, 297]`.
            *
            * @see orientation
            */
        format?: string | number[];
        /**
            * Font size in points.
            *
            * Default value: 14
            *
            * @see fontName
            */
        fontSize?: number;
        /**
            * Font name.
            *
            * Possible values:
            *
            * - `"Helvetica"` (default)
            * - `"Courier"`
            * - `"Times"`
            * - `"Symbol"`
            * - `"ZapfDingbats"`
            * - [Custom font name](https://surveyjs.io/Documentation/Pdf-Export?id=Customization-ChangeFonts#use-custom-font)
            *
            * [View Demo](https://surveyjs.io/pdf-generator/examples/change-font-in-pdf-form/ (linkStyle))
            * @see fontSize
            */
        fontName?: string;
        base64Normal?: string;
        base64Bold?: string;
        /**
            * Specifies whether to apply a custom font to [HTML questions](https://surveyjs.io/form-library/examples/questiontype-html/).
            *
            * Default value: `false`
            *
            * [View Demo](https://surveyjs.io/pdf-generator/examples/change-font-in-pdf-form/ (linkStyle))
            * @see htmlRenderAs
            */
        useCustomFontInHtml?: boolean;
        /**
            * Page margins. Set this property to an object with the following fields: `top`, `bot`, `left`, `right`.
            */
        margins?: IMargin;
        /**
            * Specifies how to render [HTML questions](https://surveyjs.io/Documentation/Library?id=questionhtmlmodel) into PDF.
            *
            * Possible values:
            *
            * - `"standard"` - Render HTML questions as selectable text.
            * - `"image"` - Render HTML questions as images.
            * - `"auto"` (default) - Select between the `"standard"` and `"image"` modes automatically based on the HTML content.
            *
            * You can override this property for an individual HTML question. Set the question's `renderAs` property to `"standard"` or `"image"` in the survey JSON schema.
            * @see useCustomFontInHtml
            */
        htmlRenderAs?: IHTMLRenderType;
        /**
            * Specifies how to render [Matrix](https://surveyjs.io/Documentation/Library?id=questionmatrixmodel), [Matrix Dropdown](https://surveyjs.io/Documentation/Library?id=questionmatrixdropdownmodel), and [Matrix Dynamic](https://surveyjs.io/Documentation/Library?id=questionmatrixdynamicmodel) questions into PDF.
            *
            * Possible values:
            *
            * - `"list"` - Render matrix-like questions as lists.
            * - `"auto"` (default) - Render matrix-like questions as tables if they fit into the available space. Otherwise, render the questions as lists.
            *
            * You can override this property for an individual matrix-like question. Set the question's `renderAs` property to `"list"` in the survey JSON schema.
            */
        matrixRenderAs?: 'auto' | 'list';
        useLegacyBooleanRendering?: boolean;
        /**
            * Specifies how to render read-only questions.
            *
            * Possible values:
            *
            * - `"text"` - Render read-only questions as plain text and custom primitives.
            * - `"acroform"` - Use Adobe AcroForms to render questions that support them as interactive form elements switched to their native read-only state. Other questions are rendered in `"text"` mode.
            * - `"auto"` (default) - Prefer the `"text"` mode but use `"acroform"` for [File Upload](https://surveyjs.io/form-library/documentation/api-reference/file-model) questions and links.
            */
        readonlyRenderAs?: 'auto' | 'text' | 'acroform';
        textFieldRenderAs?: 'singleLine' | 'multiLine';
        /**
            * Specifies whether to compress the PDF document. Compressed documents do not support [custom fonts](https://surveyjs.io/Documentation/Pdf-Export?id=Customization-ChangeFonts#use-custom-font).
            *
            * Default value: `false`
            */
        compress?: boolean;
        /**
            * Specifies whether to apply `imageFit` settings specified in the survey JSON schema to exported images.
            *
            * Default value: `false`
            *
            * This property applies the following settings:
            *
            * - [`imageFit`](https://surveyjs.io/form-library/documentation/api-reference/add-image-to-survey#imageFit) to exported [Image](https://surveyjs.io/form-library/documentation/api-reference/add-image-to-survey) questions
            * - [`imageFit`](https://surveyjs.io/form-library/documentation/api-reference/image-picker-question-model#imageFit) to exported [Image Picker](https://surveyjs.io/form-library/documentation/api-reference/image-picker-question-model) questions
            * - [`logoFit`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#logoFit) to an exported logo in the survey header
            *
            * If you enable the `applyImageFit` property, the quality of images may be lower because they pass through several conversions. If `applyImageFit` is disabled, exported images fill the entire container and do not preserve their aspect ratio, but their quality remains the same because they are exported as is.
            */
        applyImageFit?: boolean;
        /**
            * Specifies whether the PDF document contains text in right-to-left languages.
            *
            * Default value: `false`
            */
        isRTL?: boolean;
        /**
            * Specifies whether to include only selected choices when PDF Generator renders a [Multi-Select Dropdown (Tag Box)](https://surveyjs.io/form-library/examples/how-to-create-multiselect-tag-box/) question.
            *
            * Default value: `false` (include all choices)
            */
        tagboxSelectedChoicesOnly?: boolean;
}
export declare class DocOptions implements IDocOptions {
        static readonly MM_TO_PT: number;
        static readonly FONT_SIZE = 14;
        protected _orientation: 'l' | 'p';
        protected _format: string | number[];
        protected _fontSize: number;
        protected _fontName: string;
        static SEGOE_NORMAL: string;
        static SEGOE_BOLD: string;
        protected _base64Normal: string;
        protected _base64Bold: string;
        protected _useCustomFontInHtml: boolean;
        protected _margins: IMargin;
        protected _htmlRenderAs: IHTMLRenderType;
        protected _matrixRenderAs: 'auto' | 'list';
        protected _readonlyRenderAs: 'auto' | 'text' | 'acroform';
        protected _compress: boolean;
        protected _applyImageFit: boolean;
        protected _useLegacyBooleanRendering: boolean;
        protected _isRTL: boolean;
        protected _tagboxSelectedChoicesOnly: boolean;
        constructor(options: IDocOptions);
        get leftTopPoint(): IPoint;
        get fontSize(): number;
        get fontName(): string;
        get base64Normal(): string;
        get base64Bold(): string;
        get useCustomFontInHtml(): boolean;
        get margins(): IMargin;
        get format(): string | number[];
        get orientation(): 'l' | 'p';
        get htmlRenderAs(): IHTMLRenderType;
        get matrixRenderAs(): 'auto' | 'list';
        get readonlyRenderAs(): 'auto' | 'text' | 'acroform';
        get compress(): boolean;
        get applyImageFit(): boolean;
        get useLegacyBooleanRendering(): boolean;
        get isRTL(): boolean;
        get tagboxSelectedChoicesOnly(): boolean;
}
/**
    * The `DocController` object includes an API that allows you to configure the resulting PDF document. You can access this object within functions that handle the `SurveyPDF`'s [`onRender...`](https://surveyjs.io/pdf-generator/documentation/api-reference/surveypdf#onRenderFooter) events.
    *
    * [View Demo](https://surveyjs.io/pdf-generator/examples/how-to-use-adorners-in-pdf-forms/ (linkStyle))
    */
export declare class DocController extends DocOptions {
        constructor(options?: IDocOptions);
        static customFonts: {
                [name: string]: {
                        normal: string;
                        bold: string;
                        italic: string;
                        bolditalic: string;
                };
        };
        static addFont(fontName: string, base64: string, fontStyle: 'normal' | 'bold' | 'italic' | 'bolditalic'): void;
        get doc(): any;
        get helperDoc(): any;
        get fontName(): string;
        set fontName(fontName: string);
        get fontSize(): number;
        set fontSize(fontSize: number);
        get fontStyle(): string;
        set fontStyle(fontStyle: string);
        measureText(text?: string | LocalizableString | number, fontStyle?: string, fontSize?: number): ISize;
        /**
            * The width of one character in pixels.
            */
        get unitWidth(): number;
        /**
            * The heigth of one character in pixels.
            */
        get unitHeight(): number;
        pushMargins(left?: number, right?: number): void;
        popMargins(): void;
        /**
            * The width of a PDF page in pixels.
            */
        get paperWidth(): number;
        /**
            * The height of a PDF page in pixels.
            */
        get paperHeight(): number;
        getNumberOfPages(): number;
        addPage(): void;
        getCurrentPageIndex(): number;
        setPage(index: number): void;
}

export type FlatConstructor = new (survey: SurveyPDF, question: IQuestion, controller: DocController) => IFlatQuestion;
export declare class FlatRepository {
    static getInstance(): FlatRepository;
    register(modelType: string, rendererConstructor: FlatConstructor): void;
    isTypeRegistered(type: string): boolean;
    getRenderer(type: string): FlatConstructor;
    create(survey: SurveyPDF, question: Question, docController: DocController, type?: string): IFlatQuestion;
    static register(type: string, rendererConstructor: FlatConstructor): void;
    static getRenderer(type: string): FlatConstructor;
}

export interface IFlatQuestion {
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
    generateFlats(point: IPoint): Promise<IPdfBrick[]>;
}
export declare class FlatQuestion implements IFlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    static CONTENT_GAP_VERT_SCALE: number;
    static CONTENT_GAP_HOR_SCALE: number;
    static CONTENT_INDENT_SCALE: number;
    static DESC_GAP_SCALE: number;
    protected question: Question;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsComposite(point: IPoint): Promise<IPdfBrick[]>;
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
    generateFlatsContentWithOptionalElements(point: IPoint): Promise<IPdfBrick[]>;
    generateFlats(point: IPoint): Promise<IPdfBrick[]>;
    protected get shouldRenderAsComment(): boolean;
}

export declare class FlatQuestionDefault extends FlatQuestion {
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatBooleanCheckbox extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionBooleanModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}
export declare class FlatBoolean extends FlatRadiogroup {
    protected survey: SurveyPDF;
    protected controller: DocController;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    protected getVisibleChoices(): Array<ItemValue>;
    protected getColCount(): number;
}

export declare class FlatCheckbox extends FlatSelectBase {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionCheckboxModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatItem(rect: IRect, item: ItemValue, index: number): IPdfBrick;
}
export declare class FlatTagbox extends FlatCheckbox {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionTagboxModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    protected getVisibleChoices(): Array<ItemValue>;
}

export declare class FlatCustomModel extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatComment extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionCommentModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatDropdown extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionDropdownModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatExpression extends FlatQuestion {
    protected survey: SurveyPDF;
    protected question: QuestionExpressionModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatFile extends FlatQuestion {
    protected survey: SurveyPDF;
    static readonly IMAGE_GAP_SCALE: number;
    static readonly TEXT_MIN_SCALE: number;
    static DEFAULT_IMAGE_FIT: string;
    protected question: QuestionFileModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export type IHTMLRenderType = 'auto' | 'standard' | 'image';
export declare class FlatHTML extends FlatQuestion {
    protected survey: SurveyPDF;
    protected question: QuestionHtmlModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    protected correctHtml(html: string): string;
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatImage extends FlatQuestion {
    protected survey: SurveyPDF;
    protected question: QuestionImageModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatImagePicker extends FlatQuestion {
    protected survey: SurveyPDF;
    protected question: QuestionImagePickerModel;
    protected radio: FlatRadiogroup;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatPanelDynamic extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionPanelDynamicModel;
    static readonly GAP_BETWEEN_PANELS: number;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatRadiogroup extends FlatSelectBase {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionRadiogroupModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    protected isItemSelected(item: ItemValue, checked?: boolean): boolean;
    generateFlatItem(rect: IRect, item: ItemValue, index: number, key?: string, checked?: boolean, context?: any): IPdfBrick;
}

export declare class FlatRanking extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionRankingModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    protected generateFlatComposite(point: IPoint, item: ItemValue, index: number, unrankedItem?: boolean): Promise<IPdfBrick>;
    generateChoicesColumn(point: IPoint, choices: ItemValue[], unrankedChoices?: boolean): Promise<IPdfBrick[]>;
    generateSelectToRankItemsVertically(point: IPoint): Promise<IPdfBrick[]>;
    generateSelectToRankItemsHorizontally(point: IPoint): Promise<IPdfBrick[]>;
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatRating extends FlatRadiogroup {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected questionRating: QuestionRatingModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    protected generateFlatHorisontalComposite(point: IPoint, item: ItemValue, index: number): Promise<IPdfBrick>;
    protected generateFlatComposite(point: IPoint, item: ItemValue, index: number): Promise<IPdfBrick>;
    protected generateHorisontallyItems(point: IPoint): Promise<CompositeBrick[]>;
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare abstract class FlatSelectBase extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionCheckboxBase;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    abstract generateFlatItem(rect: IRect, item: ItemValue, index: number): IPdfBrick;
    protected generateFlatComposite(point: IPoint, item: ItemValue, index: number): Promise<IPdfBrick>;
    protected getVisibleChoices(): Array<ItemValue>;
    protected getColCount(): number;
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
    protected generateVerticallyItems(point: IPoint, itemValues: ItemValue[]): Promise<IPdfBrick[]>;
    protected generateHorisontallyItems(point: IPoint, colCount: number): Promise<IPdfBrick[]>;
}

export declare class FlatSignaturePad extends FlatQuestion {
    protected survey: SurveyPDF;
    protected question: QuestionSignaturePadModel;
    static BORDER_STYLE: 'dashed' | 'solid' | 'none';
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateBackgroundImage(point: IPoint): Promise<IPdfBrick>;
    generateSign(point: IPoint): Promise<IPdfBrick>;
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatTextbox extends FlatQuestion {
    protected survey: SurveyPDF;
    static readonly MULTILINE_TEXT_ROWS_COUNT: number;
    protected question: QuestionTextModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatSurvey {
    static QUES_GAP_VERT_SCALE: number;
    static PANEL_CONT_GAP_SCALE: number;
    static PANEL_DESC_GAP_SCALE: number;
    static generateFlatsPanel(survey: SurveyPDF, controller: DocController, panel: PanelModel, point: IPoint): Promise<IPdfBrick[]>;
    static generateFlats(survey: SurveyPDF, controller: DocController): Promise<IPdfBrick[][]>;
}

export declare class FlatMatrix extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    static readonly GAP_BETWEEN_ROWS: number;
    protected question: QuestionMatrixModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    protected generateFlatsHeader(point: IPoint): Promise<IPdfBrick[]>;
    protected generateFlatsRows(point: IPoint, isVertical: boolean): Promise<IPdfBrick[]>;
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}
export declare class FlatMatrixRow extends FlatRadiogroup {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected isFirst: boolean;
    protected isVertical: boolean;
    protected questionMatrix: QuestionMatrixModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController, row: MatrixRowModel, rowIndex: number, key: string, isFirst: boolean, isVertical: boolean, rowTitleWidth: number, columnWidth: number);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
    protected generateTextComposite(point: IPoint, column: ItemValue, index: number): Promise<IPdfBrick>;
    protected generateItemCompoiste(point: IPoint, column: ItemValue, index: number): Promise<IPdfBrick>;
    protected generateFlatsHorizontallyCells(point: IPoint): Promise<(IPdfBrick | CompositeBrick)[]>;
    protected generateFlatsVerticallyCells(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatMatrixMultiple extends FlatQuestion {
    protected survey: SurveyPDF;
    protected isMultiple: boolean;
    static readonly GAP_BETWEEN_ROWS: number;
    protected question: QuestionMatrixDropdownModelBase;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController, isMultiple?: boolean);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatMatrixDynamic extends FlatMatrixMultiple {
    protected survey: SurveyPDF;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
}

export declare class FlatMultipleText extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    static readonly ROWS_GAP_SCALE: number;
    protected question: QuestionMultipleTextModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class PagePacker {
    static pack(flats: IPdfBrick[][], controller: DocController): IPdfBrick[][];
}

export declare class EventAsync<Sender, Options> extends EventBase<Sender, Options> {
    unshift(func: (sender: Sender, options: Options) => any): void;
    fire(sender: Sender, options: Options): Promise<void>;
}
export declare class EventHandler {
    static process_header_events(survey: SurveyPDF, controller: DocController, packs: IPdfBrick[][]): Promise<void>;
}

/**
    * Horizontal alignment types in onRenderHeader and onRenderFooter events
    */
export declare enum HorizontalAlign {
        NotSet = "notset",
        Left = "left",
        Center = "center",
        Right = "right"
}
/**
    * Vertical alignment types in onRenderHeader and onRenderFooter events
    */
export declare enum VerticalAlign {
        NotSet = "notset",
        Top = "top",
        Middle = "middle",
        Bottom = "bottom"
}
export interface IDrawRectOptions {
        /**
            * Horizontal alignment within the rectangle that limits the drawing area.
            *
            * Possible values:
            *
            * - `"center"` (default)
            * - `"left"`
            * - `"right"`
            */
        horizontalAlign?: HorizontalAlign;
        /**
            * Vertical alignment within the rectangle that limits the drawing area.
            *
            * Possible values:
            *
            * - `"middle"` (default)
            * - `"top"`
            * - `"bottom"`
            */
        verticalAlign?: VerticalAlign;
        /**
            * The distance between the content and the borders of the rectangle. This property applies only if the content is aligned to the left/right or top/bottom.
            */
        margins?: IMargin;
        /**
            * An object with coordinates of the rectangle.
            */
        rect?: IRect;
}
/**
    * An object that configures rendering a piece of text.
    */
export interface IDrawTextOptions extends IDrawRectOptions {
        /**
            * A text string to be drawn.
            */
        text: string;
        /**
            * Font size in points.
            *
            * Default value: 14
            */
        fontSize?: number;
        /**
            * Enable this property to render the text string bold.
            *
            * Default value: `false`
            */
        isBold?: boolean;
}
/**
    * An object that configures rendering an image.
    */
export interface IDrawImageOptions extends IDrawRectOptions {
        /**
            * An image width in pixels. Defaults to the [rectangle width](https://surveyjs.io/pdf-generator/documentation/api-reference/idrawimageoptions#rect).
            */
        width?: number;
        /**
            * An image height in pixels. Defaults to the [rectangle height](https://surveyjs.io/pdf-generator/documentation/api-reference/idrawimageoptions#rect).
            */
        height?: number;
        /**
            * A string value with a base64-encoded image to be drawn.
            */
        base64: string;
        /**
            * Specifies how to resize the image to fit it into its container.
            *
            * Default value: `"contain"` if [`applyImageFit`](https://surveyjs.io/pdf-generator/documentation/api-reference/idocoptions#applyImageFit) is enabled or `undefined` if not.
            *
            * Refer to the [`object-fit`](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) CSS property description for information on accepted values.
            */
        imageFit?: string;
}
/**
    * An object that describes a drawing area and enables you to draw an image or a piece of text within the area. You can access this object within functions that handle `SurveyPDF`'s [`onRenderHeader`](https://surveyjs.io/pdf-generator/documentation/api-reference/surveypdf#onRenderHeader) and [`onRenderFooter`](https://surveyjs.io/pdf-generator/documentation/api-reference/surveypdf#onRenderFooter) events.
    *
    * [View Demo](https://surveyjs.io/pdf-generator/examples/customize-header-and-footer-of-pdf-form/ (linkStyle))
    */
export declare class DrawCanvas {
        protected packs: IPdfBrick[];
        controller: DocController;
        protected _rect: IRect;
        protected _countPages: number;
        protected _pageNumber: number;
        constructor(packs: IPdfBrick[], controller: DocController, _rect: IRect, _countPages: number, _pageNumber: number);
        /**
            * A total number of pages in the document.
            */
        get pageCount(): number;
        get countPages(): number;
        /**
            * The number of the page that contains the drawing area. Enumeration starts with 1.
            */
        get pageNumber(): number;
        /**
            * An object with coordinates of a rectangle that limits the drawing area. This object contain the following fields: `xLeft`, `xRight`, `yTop`, `yBot`.
            */
        get rect(): IRect;
        /**
            * Draws a piece of text within the drawing area.
            * @param textOptions An [`IDrawTextOptions`](https://surveyjs.io/pdf-generator/documentation/api-reference/idrawtextoptions) object that configures the drawing.
            */
        drawText(textOptions: IDrawTextOptions): void;
        /**
            * Draws an image within the drawing area.
            * @param imageOptions An [`IDrawImageOptions`](https://surveyjs.io/pdf-generator/documentation/api-reference/idrawimageoptions) object that configures drawing.
            */
        drawImage(imageOptions: IDrawImageOptions): Promise<void>;
}

export type TranslateXFunction = (xLeft: number, xRight: number) => {
        xLeft: number;
        xRight: number;
};
export interface IPdfBrick extends IRect, ISize {
        render(): Promise<void>;
        unfold(): IPdfBrick[];
        translateX(func: TranslateXFunction): void;
        isPageBreak: boolean;
}
/**
    * An object that describes a PDF brick&mdash;a simple element with specified content, size, and location. Bricks are fundamental elements used to construct a PDF document.
    *
    * You can access `PdfBrick` objects within functions that handle `SurveyPDF`'s [`onRenderQuestion`](https://surveyjs.io/pdf-generator/documentation/api-reference/surveypdf#onRenderQuestion), [`onRenderPanel`](https://surveyjs.io/pdf-generator/documentation/api-reference/surveypdf#onRenderPanel), and [`onRenderPage`](https://surveyjs.io/pdf-generator/documentation/api-reference/surveypdf#onRenderPage) events.
    *
    * [View Demo](https://surveyjs.io/pdf-generator/examples/add-markup-to-customize-pdf-forms/ (linkStyle))
    */
export declare class PdfBrick implements IPdfBrick {
        protected question: IQuestion;
        protected controller: DocController;
        protected _xLeft: number;
        protected _xRight: number;
        protected _yTop: number;
        protected _yBot: number;
        /**
            * An X-coordinate for the left brick edge.
            */
        get xLeft(): number;
        set xLeft(val: number);
        /**
            * An X-coordinate for the right brick edge.
            */
        get xRight(): number;
        set xRight(val: number);
        /**
            * A Y-coordinate for the top brick edge.
            */
        get yTop(): number;
        set yTop(val: number);
        /**
            * A Y-coordinate for the bottom brick edge.
            */
        get yBot(): number;
        set yBot(val: number);
        /**
            * Font size in points.
            *
            * Default value: 14 (inherited from the parent PDF document)
            */
        fontSize: number;
        /**
            * The color of text within the brick.
            *
            * Default value: `"#404040"`
            */
        textColor: string;
        formBorderColor: string;
        isPageBreak: boolean;
        constructor(question: IQuestion, controller: DocController, rect: IRect);
        translateX(func: TranslateXFunction): void;
        /**
            * The brick's width in pixels.
            */
        get width(): number;
        /**
            * The brick's height in pixels.
            */
        get height(): number;
        protected getShouldRenderReadOnly(): boolean;
        afterRenderCallback: () => void;
        render(): Promise<void>;
        renderInteractive(): Promise<void>;
        renderReadOnly(): Promise<void>;
        /**
            * Allows you to get a flat array of nested PDF bricks.
            * @returns A flat array of nested PDF bricks.
            */
        unfold(): IPdfBrick[];
        protected getCorrectedText(val: string): string;
        protected setXLeft(val: number): void;
        protected setXRight(val: number): void;
        protected setYTop(val: number): void;
        protected setYBottom(val: number): void;
}

export declare class BooleanItemBrick extends CheckItemBrick {
    constructor(question: IQuestion, controller: DocController, rect: IRect);
}

export declare class CheckboxItemBrick extends CheckItemBrick {
    constructor(question: IQuestion, controller: DocController, rect: IRect, item: ItemValue, index: number);
}

export interface ICheckItemBrickContext {
    question: IQuestion;
    readOnly: boolean;
    checked: boolean;
    item?: ItemValue;
    index?: number;
}
export declare class CheckItemBrick extends PdfBrick {
    protected fieldName: string;
    protected context: ICheckItemBrickContext;
    static readonly CHECKMARK_READONLY_FONT_SIZE_SCALE: number;
    protected question: QuestionCheckboxModel;
    constructor(controller: DocController, rect: IRect, fieldName: string, context: ICheckItemBrickContext);
    protected getShouldRenderReadOnly(): boolean;
    renderInteractive(): Promise<void>;
    renderReadOnly(): Promise<void>;
}

export declare class CommentBrick extends TextBoxBrick {
    protected controller: DocController;
    constructor(question: IQuestion, controller: DocController, rect: IRect, isQuestion: boolean, index?: number);
    protected shouldRenderFlatBorders(): boolean;
}

export declare class CompositeBrick implements IPdfBrick {
    isPageBreak: boolean;
    constructor(...bricks: IPdfBrick[]);
    get xLeft(): number;
    set xLeft(xLeft: number);
    get xRight(): number;
    set xRight(xRight: number);
    get yTop(): number;
    set yTop(yTop: number);
    get yBot(): number;
    set yBot(yBot: number);
    get width(): number;
    get height(): number;
    render(): Promise<void>;
    get isEmpty(): boolean;
    addBrick(...bricks: IPdfBrick[]): void;
    unfold(): IPdfBrick[];
    translateX(func: TranslateXFunction): void;
}

export declare class CustomBrick extends PdfBrick {
    constructor(question: IQuestion, controller: DocController, renderFunc: (doc: any, question: any, xLeft: number, yTop: number) => IRect);
    renderInteractive(): Promise<void>;
}

export declare class DropdownBrick extends PdfBrick {
    protected controller: DocController;
    protected question: QuestionDropdownModel;
    protected isQuestion: boolean;
    protected isMultiline: boolean;
    constructor(question: IQuestion, controller: DocController, rect: IRect);
    renderInteractive(): Promise<void>;
}

export declare class EmptyBrick extends PdfBrick {
    protected controller: DocController;
    constructor(rect: IRect, controller?: DocController, isBorderVisible?: boolean);
    renderInteractive(): Promise<void>;
}

export declare class HTMLBrick extends PdfBrick {
    protected html: string;
    constructor(question: IQuestion, controller: DocController, rect: IRect, html: string, isImage?: boolean);
    renderInteractive(): Promise<void>;
}

export declare class ImageBrick extends PdfBrick {
    protected image: string;
    protected originalWidth: number;
    protected originalHeight: number;
    constructor(question: IQuestion, controller: DocController, image: string, point: IPoint, originalWidth: number, originalHeight: number);
    renderInteractive(): Promise<void>;
}

export declare class LinkBrick extends TextBrick {
    protected link: string;
    static readonly COLOR: string;
    constructor(textFlat: TextBrick, link: string);
    renderInteractive(): Promise<void>;
    renderReadOnly(): Promise<void>;
}

export interface IRadiogroupWrapContext {
    question: IQuestion;
    readOnly: boolean;
}
export declare class RadioGroupWrap {
    name: string;
    constructor(name: string, controller: DocController, context: IRadiogroupWrapContext);
    addToPdf(color: string): void;
    get radioGroup(): any;
    get readOnly(): boolean;
}
export interface IRadioGroupItemBrickContext {
    question: IQuestion;
    checked: boolean;
    index: number;
    item: ItemValue;
}
export declare class RadioItemBrick extends PdfBrick {
    static readonly RADIOMARKER_READONLY_FONT_SIZE_SCALE: number;
    constructor(controller: DocController, rect: IRect, context: IRadioGroupItemBrickContext, radioGroupWrap: RadioGroupWrap);
    protected getShouldRenderReadOnly(): boolean;
    renderInteractive(): Promise<void>;
    renderReadOnly(): Promise<void>;
}

export declare class RankingItemBrick extends PdfBrick {
    protected mark: string;
    protected question: QuestionRankingModel;
    constructor(question: IQuestion, controller: DocController, rect: IRect, mark: string);
    renderInteractive(): Promise<void>;
}

export declare class RowlineBrick implements IPdfBrick {
    protected controller: DocController;
    protected color: string;
    xLeft: number;
    xRight: number;
    yTop: number;
    yBot: number;
    isPageBreak: boolean;
    constructor(controller: DocController, rect: IRect, color: string);
    get width(): number;
    get height(): number;
    render(): Promise<void>;
    unfold(): IPdfBrick[];
    translateX(_: TranslateXFunction): void;
}

export declare class TextFieldBrick extends PdfBrick {
    protected isQuestion: boolean;
    protected fieldName: string;
    protected value: string;
    protected placeholder: string;
    isReadOnly: boolean;
    protected isMultiline: boolean;
    protected inputType: string;
    protected question: QuestionTextModel;
    constructor(question: IQuestion, controller: DocController, rect: IRect, isQuestion: boolean, fieldName: string, value: string, placeholder: string, isReadOnly: boolean, isMultiline: boolean, inputType: string);
    renderInteractive(): Promise<void>;
    protected shouldRenderFlatBorders(): boolean;
    protected getShouldRenderReadOnly(): boolean;
    get textBrick(): IPdfBrick;
    set textBrick(val: IPdfBrick);
    renderReadOnly(): Promise<void>;
    unfold(): IPdfBrick[];
    translateX(func: TranslateXFunction): void;
    protected setXLeft(val: number): void;
    protected setXRight(val: number): void;
    protected setYTop(val: number): void;
    protected setYBottom(val: number): void;
}

export declare class TextBoldBrick extends TextBrick {
    constructor(question: IQuestion, controller: DocController, rect: IRect, text: string);
    renderInteractive(): Promise<void>;
}

export declare class TextBoxBrick extends TextFieldBrick {
    protected isQuestion: boolean;
    protected isMultiline: boolean;
    constructor(question: IQuestion, controller: DocController, rect: IRect, isQuestion?: boolean, isMultiline?: boolean, index?: number);
}

export declare class TextBrick extends PdfBrick {
    protected text: string;
    protected align: any;
    constructor(question: IQuestion, controller: DocController, rect: IRect, text: string);
    renderInteractive(): Promise<void>;
    protected alignPoint(rect: IRect): IPoint;
}

export declare class TitlePanelBrick extends TextBoldBrick {
    protected question: QuestionTextModel;
    constructor(question: IQuestion, controller: DocController, rect: IRect, text: string);
    renderInteractive(): Promise<void>;
}

export declare class AdornersBaseOptions {
    point: IPoint;
    bricks: IPdfBrick[];
    controller: DocController;
    repository: FlatRepository;
    module: any;
    constructor(point: IPoint, bricks: IPdfBrick[], controller: DocController, repository: FlatRepository, module: any);
}
export declare class AdornersOptions extends AdornersBaseOptions {
    question: Question;
    constructor(point: IPoint, bricks: IPdfBrick[], question: Question, controller: DocController, repository: FlatRepository, module: any);
}
export declare class AdornersPanelOptions extends AdornersBaseOptions {
    panel: PanelModel;
    constructor(point: IPoint, bricks: IPdfBrick[], panel: PanelModel, controller: DocController, repository: FlatRepository, module: any);
}
export declare class AdornersPageOptions extends AdornersBaseOptions {
    page: PageModel;
    constructor(point: IPoint, bricks: IPdfBrick[], page: PageModel, controller: DocController, repository: FlatRepository, module: any);
}


